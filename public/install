#!/bin/bash

# Script to install infinity-metrics-installer
# Run as: curl -fsSL https://getinfinitymetrics.com/install | bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Create a temporary script that will be executed directly
TMP_SCRIPT=$(mktemp)
cat > "$TMP_SCRIPT" << 'EOF'
#!/bin/bash

# Verify running as root
if [ "$(id -u)" -ne 0 ]; then
    echo -e "${RED}Error: This script requires root privileges.${NC}"
    echo "Running with sudo..."
    exec sudo "$0" "$@"
    exit 1
fi

# Rest of your installation logic
# Detect architecture
ARCH=$(uname -m)
case "$ARCH" in
    x86_64)
        ARCH="amd64"
        ;;
    aarch64|arm64)
        ARCH="arm64"
        ;;
    *)
        echo -e "${RED}Unsupported architecture: $ARCH. Only amd64 and arm64 are supported.${NC}"
        exit 1
        ;;
esac

# Define installation directory and paths
INSTALL_DIR="/usr/local/bin"
BINARY_PATH="$INSTALL_DIR/infinity-metrics"
TEMP_FILE="/tmp/infinity-metrics-$ARCH"

# GitHub repository info
GITHUB_REPO="karloscodes/infinity-metrics-installer"

# Install jq if not present
if ! command -v jq >/dev/null 2>&1; then
    echo "Installing jq for JSON parsing..."
    apt-get install -y -qq jq || {
        echo -e "${RED}Error: Failed to install jq.${NC}"
        exit 1
    }
fi

# Fetch the latest release information
echo "Fetching latest release information..."
RELEASE_INFO=$(curl -fsSL "https://api.github.com/repos/$GITHUB_REPO/releases/latest")

# Error handling
if echo "$RELEASE_INFO" | grep -q "API rate limit exceeded"; then
    echo -e "${RED}Error: GitHub API rate limit exceeded.${NC}"
    exit 1
fi

if echo "$RELEASE_INFO" | grep -q "Not Found"; then
    echo -e "${RED}Error: No releases found in $GITHUB_REPO.${NC}"
    exit 1
fi

# Extract the latest version
LATEST_VERSION=$(echo "$RELEASE_INFO" | jq -r '.tag_name' | sed 's/^v//')

if [ -z "$LATEST_VERSION" ]; then
    echo -e "${RED}Error: Could not determine latest version.${NC}"
    exit 1
fi

echo "Latest version: $LATEST_VERSION"

# Find the correct asset
echo "Finding asset for architecture ($ARCH)..."
ASSET_NAMES=$(echo "$RELEASE_INFO" | jq -r '.assets[].name')
ASSET_NAME=""

for name in $ASSET_NAMES; do
    if echo "$name" | grep -qi "infinity-metrics.*$ARCH"; then
        ASSET_NAME="$name"
        break
    fi
done

if [ -z "$ASSET_NAME" ]; then
    echo -e "${RED}Error: No binary found for $ARCH in release v$LATEST_VERSION.${NC}"
    exit 1
fi

# Construct the download URL
BINARY_URL="https://github.com/$GITHUB_REPO/releases/download/v$LATEST_VERSION/$ASSET_NAME"
echo "Download URL: $BINARY_URL"

# Download the binary
echo "Downloading Infinity Metrics v$LATEST_VERSION for $ARCH..."
curl -L --fail --progress-bar -o "$TEMP_FILE" "$BINARY_URL" || {
    echo -e "${RED}Error: Failed to download binary.${NC}"
    rm -f "$TEMP_FILE"
    exit 1
}

# Verify the download
if [ ! -s "$TEMP_FILE" ]; then
    echo -e "${RED}Error: Downloaded file is empty.${NC}"
    rm -f "$TEMP_FILE"
    exit 1
fi

# Check file type
FILE_TYPE=$(file "$TEMP_FILE")
echo "Verifying file: $FILE_TYPE"
if ! echo "$FILE_TYPE" | grep -q "ELF"; then
    echo -e "${RED}Error: Downloaded file is not a valid binary.${NC}"
    rm -f "$TEMP_FILE"
    exit 1
fi

# Install the binary
echo "Installing to $BINARY_PATH..."
mv "$TEMP_FILE" "$BINARY_PATH" && chmod +x "$BINARY_PATH" || {
    echo -e "${RED}Error: Failed to install binary.${NC}"
    rm -f "$TEMP_FILE"
    exit 1
}

# Run the installer with interactive terminal
echo -e "${GREEN}Running Infinity Metrics installer...${NC}"
"$BINARY_PATH" install

echo -e "${GREEN}Installation complete!${NC}"
EOF

# Make the temporary script executable
chmod +x "$TMP_SCRIPT"

# Inform the user what's happening
echo -e "${GREEN}Infinity Metrics Installer${NC}"
echo "Setting up installation script..."
echo "This will download and run the interactive installer."
echo ""

# Execute the temporary script in a new terminal session
echo "Starting installation..."
exec "$TMP_SCRIPT"

# Clean up (this won't execute due to exec above, but included for clarity)
rm -f "$TMP_SCRIPT"
